<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pixel Animation Studio</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Base styles & Dark Yellowish Theme */
        body { 
            font-family: 'Inter', sans-serif; 
            background-color: #1c1917; /* Stone 900 - Dark Base */
            color: #f5f5f4; /* Stone 100 - Primary Text */
        }
        .editor-container { max-width: 1400px; }
        .bg-panel { background-color: #292524; /* Stone 800 - Panel Background */ }
        .text-accent { color: #f59e0b; /* Amber 500 - Accent Color */ }

        /* Canvas styles - Monochrome Display */
        #gridCanvas, #playerCanvas {
            border: 2px solid #a1a1aa; /* Stone 400 */
            background-color: #e5e5e5; /* Very light grey/off-white (Monochrome screen) */
            touch-action: none;
            image-rendering: crisp-edges;
            image-rendering: pixelated;
            width: 100%;
            height: auto;
        }

        /* Tab styles (Solid buttons, less rounded) */
        .tab-btn {
            @apply px-5 py-2 font-bold text-stone-400 border-b-4 border-transparent transition-colors bg-stone-900/50 hover:text-amber-500 hover:border-amber-500 rounded-none;
        }
        .tab-btn.active-tab {
            @apply text-amber-500 border-amber-500 bg-panel shadow-inner rounded-t-md;
        }

        /* Tool active state - Boxy and defined */
        .tool-btn {
            @apply bg-stone-700 text-stone-200 hover:bg-stone-600 transition-colors border-2 border-stone-600 rounded-md;
        }
        .tool-btn.active {
            box-shadow: 0 0 0 3px #f59e0b; /* Amber shadow */
            background-color: #f59e0b; 
            color: #1c1917; /* Dark text on amber */
            border-color: #f59e0b;
        }

        /* Layer/Frame item focus/active */
        .item { @apply rounded-md transition duration-100; }
        .item.active {
            background-color: #44403c; /* Stone 700 */
            border-left: 4px solid #f59e0b;
        }
        .item:hover:not(.active) {
            background-color: #292524; 
        }

        /* Utility buttons - Solid box style */
        .action-btn {
            @apply px-4 py-2 font-semibold rounded-md shadow-lg transition-colors text-sm border-2 border-transparent;
        }

        /* Export control buttons */
        .export-control-btn {
            @apply px-4 py-2 font-semibold rounded-md shadow-lg transition-colors text-sm border-2 border-stone-500;
        }
        
        /* Input fields */
        input[type="number"] {
            @apply rounded-md;
        }

        /* Output text */
        .pixel-output {
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
    </style>
</head>
<body class="bg-theme-main min-h-screen p-4 md:p-8 flex justify-center">

    <div class="editor-container w-full">
        <h1 class="text-3xl font-extrabold text-stone-100 mb-4">Pixel Animation Studio</h1>

        <!-- Tabs -->
        <div class="flex border-b border-stone-700 mb-6">
            <button class="tab-btn active-tab" data-tab="editor">Single Frame Editor</button>
            <button class="tab-btn" data-tab="player">Animation Player</button>
        </div>

        <!-- Tab Content -->
        <div id="tab-content">
            
            <!-- Editor Tab Content -->
            <div id="editor" class="tab-page">
                <div class="grid grid-cols-1 lg:grid-cols-12 gap-6">
                    
                    <!-- LEFT PANEL: Tools and Config (col-span-3) -->
                    <div class="lg:col-span-3 space-y-6">
                        
                        <!-- Tools -->
                        <div class="bg-panel p-4 rounded-xl">
                            <h2 class="text-xl font-semibold mb-3 text-stone-100">Tools</h2>
                            <div id="toolPanel" class="grid grid-cols-4 gap-2">
                                <!-- Tools injected here -->
                            </div>
                        </div>

                        <!-- Config -->
                        <div class="bg-panel p-4 rounded-xl">
                            <h2 class="text-xl font-semibold mb-3 text-stone-100">Config</h2>
                            <div class="mb-4">
                                <label for="iconWidth" class="block text-sm font-medium text-stone-300">Width (X)</label>
                                <input type="number" id="iconWidth" value="16" min="1" max="84" class="mt-1 block w-full rounded-md border-stone-600 bg-stone-700 text-stone-100 shadow-sm p-2 border">
                            </div>
                            <div class="mb-4">
                                <label for="iconHeight" class="block text-sm font-medium text-stone-300">Height (Y)</label>
                                <input type="number" id="iconHeight" value="16" min="1" max="48" class="mt-1 block w-full rounded-md border-stone-600 bg-stone-700 text-stone-100 shadow-sm p-2 border">
                                <p class="text-xs text-stone-400 mt-1">Export is Row-Major (Y, Bank, Bit).</p>
                            </div>
                            <button id="applyResBtn" class="action-btn w-full bg-amber-600 text-stone-900 hover:bg-amber-500 border-amber-700">
                                Apply Resolution
                            </button>
                        </div>
                    </div>

                    <!-- CENTER PANEL: Canvas (col-span-6) -->
                    <div class="lg:col-span-6 bg-panel p-6 rounded-xl flex flex-col items-center">
                        <h2 class="text-xl font-semibold text-stone-100 mb-4">
                            Frame <span id="currentFrameNum" class="text-accent">1</span> (<span id="dimsText">16x16</span>)
                        </h2>
                        <div class="max-w-full overflow-hidden">
                            <canvas id="gridCanvas" width="512" height="512"></canvas>
                        </div>
                        
                        <div class="mt-4 flex space-x-4">
                            <button id="clearBtn" class="action-btn bg-red-600 text-white hover:bg-red-500 border-red-700">
                                Clear Active Layer
                            </button>
                            <button id="importBtn" class="action-btn bg-purple-600 text-white hover:bg-purple-500 border-purple-700">
                                Paste & Import C Array
                            </button>
                        </div>
                    </div>

                    <!-- RIGHT PANEL: Frames and Layers (col-span-3) -->
                    <div class="lg:col-span-3 space-y-6">

                        <!-- Frame Selector -->
                        <div class="bg-panel p-4 rounded-xl">
                            <h2 class="text-xl font-semibold mb-3 text-stone-100">Frames (<span id="totalFramesCount" class="text-accent">1</span>)</h2>
                            <div class="flex justify-between items-center mb-2">
                                <p class="text-sm font-medium text-stone-300">Sequence List</p>
                                <div id="frameNav" class="flex space-x-2">
                                    <button id="moveFrameUpBtn" class="p-1 text-lg text-amber-500 hover:text-amber-300 disabled:opacity-50" title="Move Frame Up (Earlier)">
                                        ‚ñ≤
                                    </button>
                                    <button id="moveFrameDownBtn" class="p-1 text-lg text-amber-500 hover:text-amber-300 disabled:opacity-50" title="Move Frame Down (Later)">
                                        ‚ñº
                                    </button>
                                </div>
                            </div>
                            <div id="frameList" class="space-y-1 max-h-32 overflow-y-auto mb-4 border border-stone-700 p-2 rounded-lg">
                                <!-- Frames injected here -->
                            </div>
                            <div class="flex space-x-2">
                                <button id="duplicateFrameBtn" class="action-btn flex-1 bg-green-600 text-white hover:bg-green-500 border-green-700">
                                    Duplicate Frame
                                </button>
                                <button id="blankFrameBtn" class="action-btn flex-1 bg-amber-600 text-stone-900 hover:bg-amber-500 border-amber-700">
                                    + Blank Frame
                                </button>
                            </div>
                        </div>
                        
                        <!-- Layers -->
                        <div class="bg-panel p-4 rounded-xl">
                            <h2 class="text-xl font-semibold mb-3 text-stone-100">Layers (Active: <span id="activeLayerName" class="text-accent">Base Layer</span>)</h2>
                            <div id="layerList" class="space-y-1 max-h-40 overflow-y-auto mb-4 border border-stone-700 p-2 rounded-lg">
                                <!-- Layers injected here -->
                            </div>
                            <button id="newLayerBtn" class="action-btn w-full bg-blue-600 text-white hover:bg-blue-500 border-blue-700">
                                + New Layer
                            </button>
                        </div>
                    </div>

                    <!-- Export Panel (Full Width) -->
                    <div class="lg:col-span-12">
                        <div class="bg-stone-900 p-4 rounded-xl shadow-lg text-white border border-stone-700">
                            <h2 class="text-xl font-semibold mb-3">C Array Export (Row-Major)</h2>
                            
                            <!-- Generation Buttons -->
                            <div class="flex space-x-4 mb-3">
                                <button id="generateSingleFrameBtn" class="action-btn flex-1 bg-lime-600 text-stone-900 hover:bg-lime-500 border-lime-700">
                                    Generate Single Frame Array (<span id="singleFrameByteCount">0</span> bytes)
                                </button>
                                <button id="generateAnimationBtn" class="action-btn flex-1 bg-amber-600 text-stone-900 hover:bg-amber-500 border-amber-700">
                                    Generate Animation Array (<span id="animationByteCount">0</span> bytes)
                                </button>
                            </div>

                            <!-- Output Area -->
                            <div id="outputContainer" class="hidden">
                                <div id="byteOutput" class="pixel-output text-amber-300 text-xs h-32 overflow-y-auto p-2 bg-black rounded-md border border-stone-700 mb-3">
                                    Generated code will appear here.
                                </div>
                                
                                <div class="flex justify-end space-x-3">
                                    <button id="copyOutputBtn" class="export-control-btn bg-stone-700 text-stone-100 hover:bg-stone-600">
                                        Copy to Clipboard
                                    </button>
                                    <button id="exportCFileBtn" class="export-control-btn bg-blue-600 text-white hover:bg-blue-500">
                                        Export (Download .c file)
                                    </button>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <!-- Animation Player Tab Content -->
            <div id="player" class="tab-page hidden">
                <div class="flex flex-col items-center p-6 bg-panel rounded-xl">
                    <h2 class="text-2xl font-bold mb-4 text-stone-100">Animation Preview</h2>
                    <canvas id="playerCanvas" width="512" height="512"></canvas>
                    <div class="mt-6 flex items-center space-x-6">
                        
                        <label for="speedInput" class="text-sm font-medium text-stone-300">Speed (ms/Frame):</label>
                        <input type="number" id="speedInput" value="250" min="50" max="1000" step="50" class="w-20 p-2 border rounded-md text-center bg-stone-700 text-stone-100 border-stone-600">

                        <button id="prevFrameBtn" class="p-3 bg-stone-700 text-stone-100 hover:bg-stone-600 rounded-md transition-colors text-xl font-bold border border-stone-600" title="Previous Frame">
                            ‚óÄ
                        </button>
                        <button id="playStopBtn" class="p-4 bg-red-600 text-white hover:bg-red-500 rounded-md transition-colors text-2xl font-bold shadow-lg border border-red-700" title="Play/Stop">
                            ‚ñ∂
                        </button>
                        <button id="nextFrameBtn" class="p-3 bg-stone-700 text-stone-100 hover:bg-stone-600 rounded-md transition-colors text-xl font-bold border border-stone-600" title="Next Frame">
                            ‚ñ∂
                        </button>
                    </div>
                    <p class="mt-4 text-lg font-medium text-stone-100">
                        Current Frame: <span id="playerCurrentFrame" class="text-accent">1</span> / <span id="playerTotalFrames" class="text-accent">1</span>
                    </p>
                </div>
            </div>

        </div> <!-- End Tab Content -->
    </div>

    <!-- Import Modal (updated for theme) -->
    <div id="importModal" class="modal-overlay hidden">
        <div class="bg-panel p-6 rounded-xl shadow-2xl w-full max-w-lg">
            <h2 class="text-2xl font-bold mb-4 text-stone-100">Import C Array Data</h2>
            
            <textarea id="arrayInput" class="w-full h-32 p-3 border border-stone-600 bg-stone-700 text-stone-100 rounded-md font-mono text-sm resize-none focus:ring-amber-500 focus:border-amber-500" placeholder="Paste your const uint8_t array here..."></textarea>
            
            <div class="flex items-center justify-between mt-3 mb-4">
                <button id="previewArrayBtn" class="action-btn bg-amber-600 text-stone-900 hover:bg-amber-500 border-amber-700">
                    Preview Array
                </button>
                <div class="text-sm text-stone-300">
                    <span id="previewDims">W: ? H: ?</span> | <span id="previewBytes">Bytes: ?</span>
                </div>
            </div>

            <div class="text-center mb-4 p-2 border border-dashed border-stone-600 rounded-lg">
                <h3 class="text-lg font-medium mb-2 text-stone-100">Preview</h3>
                <canvas id="previewCanvas" width="128" height="128" class="border border-stone-400 mx-auto" style="image-rendering: pixelated;"></canvas>
                <p id="previewError" class="text-red-500 mt-2 text-sm hidden">Error during parsing.</p>
            </div>

            <div class="flex justify-end space-x-3">
                <button id="cancelImportBtn" class="action-btn bg-stone-600 text-stone-100 hover:bg-stone-500 border-stone-700">
                    Cancel
                </button>
                <button id="commitImportBtn" disabled class="action-btn bg-green-600 text-white opacity-50 cursor-not-allowed border-green-700">
                    Import to Active Layer
                </button>
            </div>
        </div>
    </div>

    <script>
        // --- Configuration & State ---
        const MAX_CANVAS_WIDTH = 512; 
        let iconWidth = 16;
        let iconHeight = 16;
        let pixelSize = MAX_CANVAS_WIDTH / iconWidth; 
        
        let frames = []; // Array of { name: string, layers: Layer[] }
        let currentFrameIndex = 0;
        let activeLayerIndex = 0;
        let currentTool = 'pencil';
        
        let isDrawing = false; 
        let drawingState = 1; // 1 for drawing, 0 for erasing (for black pixel mode: 1 means pixel is ON)
        
        let startX = -1, startY = -1; 
        let previewPixels = null; 
        let layerSnapshot = null; 
        let parsedGrid = null;

        let isPlaying = false;
        let animationSpeed = 250; // ms per frame
        let lastTimestamp = 0;
        let animationFrameId = null; 
        let currentAnimationFrame = null;
        let animationFrame = 0;

        // Tool definitions
        const TOOLS = [
            { id: 'pencil', name: 'Pencil (Black)', icon: '‚úèÔ∏è', cursor: 'crosshair' },
            { id: 'eraser', name: 'Eraser (White)', icon: 'üßº', cursor: 'cell' },
        ];

        // --- DOM Elements ---
        const canvas = document.getElementById('gridCanvas');
        const ctx = canvas.getContext('2d');
        const playerCanvas = document.getElementById('playerCanvas');
        const playerCtx = playerCanvas.getContext('2d');
        const byteOutputDiv = document.getElementById('byteOutput');
        const dimsText = document.getElementById('dimsText');
        const inputWidth = document.getElementById('iconWidth');
        const inputHeight = document.getElementById('iconHeight');
        const layerListDiv = document.getElementById('layerList');
        const frameListDiv = document.getElementById('frameList');
        const toolPanelDiv = document.getElementById('toolPanel');
        const activeLayerNameSpan = document.getElementById('activeLayerName');
        const currentFrameNumSpan = document.getElementById('currentFrameNum');
        const totalFramesCountSpan = document.getElementById('totalFramesCount');
        const singleFrameByteCountSpan = document.getElementById('singleFrameByteCount');
        const animationByteCountSpan = document.getElementById('animationByteCount');

        // Animation Player Elements
        const playStopBtn = document.getElementById('playStopBtn');
        const nextFrameBtn = document.getElementById('nextFrameBtn');
        const prevFrameBtn = document.getElementById('prevFrameBtn');
        const speedInput = document.getElementById('speedInput');
        const playerCurrentFrameSpan = document.getElementById('playerCurrentFrame');
        const playerTotalFramesSpan = document.getElementById('playerTotalFrames');

        // Generation and Export Elements (NEW/RENAMED)
        const generateSingleFrameBtn = document.getElementById('generateSingleFrameBtn');
        const generateAnimationBtn = document.getElementById('generateAnimationBtn');
        const outputContainer = document.getElementById('outputContainer');
        const copyOutputBtn = document.getElementById('copyOutputBtn');
        const exportCFileBtn = document.getElementById('exportCFileBtn');
        
        // Modal Elements (omitted for brevity, assume linked)
        const importModal = document.getElementById('importModal');
        const arrayInput = document.getElementById('arrayInput');
        const previewCanvas = document.getElementById('previewCanvas');
        const previewCtx = previewCanvas.getContext('2d');
        const previewArrayBtn = document.getElementById('previewArrayBtn');
        const commitImportBtn = document.getElementById('commitImportBtn');
        const cancelImportBtn = document.getElementById('cancelImportBtn');
        const previewDimsSpan = document.getElementById('previewDims');
        const previewBytesSpan = document.getElementById('previewBytes');
        const previewErrorP = document.getElementById('previewError');
        const mainImportBtn = document.getElementById('importBtn');

        // Frame Buttons
        const duplicateFrameBtn = document.getElementById('duplicateFrameBtn');
        const blankFrameBtn = document.getElementById('blankFrameBtn');
        const moveFrameUpBtn = document.getElementById('moveFrameUpBtn');
        const moveFrameDownBtn = document.getElementById('moveFrameDownBtn');


        // --- Core State Accessors ---

        function getActiveLayers() {
            return frames[currentFrameIndex].layers;
        }
        function getActiveFrame() {
            return frames[currentFrameIndex];
        }

        // --- Utility Functions ---

        function createBlankGrid(w, h) {
            return Array.from({ length: h }, () => Array(w).fill(0));
        }

        function getPixelCoords(e) { 
            const targetCanvas = e.currentTarget;
            const rect = targetCanvas.getBoundingClientRect();
            let clientX, clientY;
            
            if (e.touches && e.touches.length > 0) {
                clientX = e.touches[0].clientX;
                clientY = e.touches[0].clientY;
            } else {
                clientX = e.clientX;
                clientY = e.clientY;
            }

            const x = Math.floor(((clientX - rect.left) / rect.width) * iconWidth);
            const y = Math.floor(((clientY - rect.top) / rect.height) * iconHeight);
            return { x, y };
        }

        function setPixel(grid, x, y, value) {
            if (x >= 0 && x < iconWidth && y >= 0 && y < iconHeight) {
                grid[y][x] = value;
            }
        }
        
        function drawLine(grid, x0, y0, x1, y1, value) {
            const dx = Math.abs(x1 - x0);
            const dy = Math.abs(y1 - y0);
            const sx = (x0 < x1) ? 1 : -1;
            const sy = (y0 < y1) ? 1 : -1;
            let err = dx - dy;
            while (true) {
                setPixel(grid, x0, y0, value);
                if ((x0 === x1) && (y0 === y1)) break;
                const e2 = 2 * err;
                if (e2 > -dy) { err -= dy; x0 += sx; }
                if (e2 < dx) { err += dx; y0 += sy; }
            }
        }

        // --- Canvas Drawing and Rendering (Monochrome update) ---

        function drawScene(targetCtx, targetCanvas, targetPixelSize, layersToRender) {
            // Background is handled by CSS: #e5e5e5
            targetCtx.clearRect(0, 0, targetCanvas.width, targetCanvas.height);
            targetCtx.strokeStyle = '#bdbdbd'; // Slightly darker grid lines on light background

            // --- 1. Onion Skinning (Previous Frame) ---
            if (targetCanvas.id === 'gridCanvas' && frames.length > 1 && currentFrameIndex > 0) {
                const prevFrameIndex = (currentFrameIndex - 1);
                const prevFrameLayers = frames[prevFrameIndex].layers;
                const prevComposite = mergeVisibleLayers(prevFrameLayers);
                
                targetCtx.fillStyle = 'rgba(0, 0, 0, 0.1)'; // Very light transparent black for ghosting
                
                for (let y = 0; y < iconHeight; y++) {
                    for (let x = 0; x < iconWidth; x++) {
                        if (prevComposite[y][x]) {
                            targetCtx.fillRect(x * targetPixelSize, y * targetPixelSize, targetPixelSize, targetPixelSize);
                        }
                    }
                }
            }
            
            // --- 2. Current Frame Layers ---
            for (let k = 0; k < layersToRender.length; k++) {
                const layer = layersToRender[k];
                if (!layer.visible) continue;

                // Use BLACK for the main pixel color
                targetCtx.fillStyle = '#000000'; 

                for (let y = 0; y < iconHeight; y++) {
                    for (let x = 0; x < iconWidth; x++) {
                        const is_set = layer.data[y][x];
                        
                        if (is_set) {
                            targetCtx.fillRect(x * targetPixelSize, y * targetPixelSize, targetPixelSize, targetPixelSize);
                        }
                    }
                }
            }

            // Only draw preview and grid on the main editor canvas
            if (targetCanvas.id === 'gridCanvas') {
                if (previewPixels) {
                    for (let y = 0; y < iconHeight; y++) {
                        for (let x = 0; x < iconWidth; x++) {
                            if (previewPixels[y][x]) {
                                targetCtx.fillStyle = '#cc0000'; // Dark red for preview
                                targetCtx.fillRect(x * targetPixelSize, y * targetPixelSize, targetPixelSize, targetPixelSize);
                            }
                        }
                    }
                }
                
                // Draw Grid
                targetCtx.strokeStyle = '#bdbdbd'; 
                for (let y = 0; y <= iconHeight; y++) {
                    targetCtx.beginPath();
                    targetCtx.moveTo(0, y * targetPixelSize);
                    targetCtx.lineTo(targetCanvas.width, y * targetPixelSize);
                    targetCtx.stroke();
                }
                for (let x = 0; x <= iconWidth; x++) {
                    targetCtx.beginPath();
                    targetCtx.moveTo(x * targetPixelSize, 0);
                    targetCtx.lineTo(x * targetPixelSize, targetCanvas.height);
                    targetCtx.stroke();
                }
            }
        }

        // --- Frame Management (Unchanged logic) ---

        function moveFrame(direction) {
            const oldIndex = currentFrameIndex;
            const newIndex = oldIndex + direction;

            if (newIndex >= 0 && newIndex < frames.length) {
                const frameToMove = frames.splice(oldIndex, 1)[0];
                frames.splice(newIndex, 0, frameToMove);
                selectFrame(newIndex);
            }
        }

        function addFrame(isDuplicate = false) {
            const newFrameIndex = frames.length;
            let newLayers = [];

            if (isDuplicate && frames.length > 0) {
                const activeLayers = getActiveLayers();
                newLayers = activeLayers.map(layer => ({
                    name: layer.name,
                    visible: layer.visible,
                    data: JSON.parse(JSON.stringify(layer.data))
                }));
            } else {
                newLayers = [{
                    name: 'Base Layer',
                    data: createBlankGrid(iconWidth, iconHeight),
                    visible: true,
                }];
            }

            frames.push({
                name: `Frame ${newFrameIndex + 1}`,
                layers: newLayers,
            });
            
            selectFrame(newFrameIndex);
        }

        function selectFrame(index) {
            if (index < 0 || index >= frames.length) return;
            currentFrameIndex = index;
            activeLayerIndex = Math.min(activeLayerIndex, getActiveLayers().length - 1);
            
            // Hide output when switching frames
            outputContainer.classList.add('hidden'); 
            
            renderFrameList();
            renderLayerList();
            updateUI();
        }

        function removeFrame(index) {
            if (frames.length > 1) {
                frames.splice(index, 1);
                if (currentFrameIndex >= index) {
                    currentFrameIndex = Math.max(0, currentFrameIndex - 1);
                }
                selectFrame(currentFrameIndex); 
            }
        }

        function renderFrameList() {
            frameListDiv.innerHTML = '';
            
            frames.forEach((frame, index) => {
                const item = document.createElement('div');
                item.className = `item flex items-center justify-between p-2 cursor-pointer transition duration-100 ${index === currentFrameIndex ? 'active' : ''}`;
                item.innerHTML = `
                    <div class="flex items-center space-x-2 w-full">
                        <span class="frame-name flex-1 text-sm font-medium truncate text-stone-100" data-index="${index}">
                            ${frame.name} (#${index + 1}) ${index === currentFrameIndex ? '<span class="text-accent">(Active)</span>' : ''}
                        </span>
                    </div>
                    <button class="delete-frame ml-2 p-1 text-sm text-red-500 rounded-md hover:bg-red-900" data-index="${index}" title="Delete Frame" ${frames.length === 1 ? 'disabled' : ''}>
                        ${frames.length === 1 ? 'üîí' : '‚ùå'}
                    </button>
                `;

                item.addEventListener('click', () => selectFrame(index));
                item.querySelector('.delete-frame').addEventListener('click', (e) => {
                    e.stopPropagation();
                    removeFrame(index);
                });
                
                frameListDiv.appendChild(item);
            });
            
            currentFrameNumSpan.textContent = currentFrameIndex + 1;
            totalFramesCountSpan.textContent = frames.length;
            playerTotalFramesSpan.textContent = frames.length;
            playerCurrentFrameSpan.textContent = (isPlaying ? frames.indexOf(currentAnimationFrame) : currentFrameIndex) + 1;

            moveFrameUpBtn.disabled = currentFrameIndex === 0;
            moveFrameDownBtn.disabled = currentFrameIndex === frames.length - 1;

            updateExportBytes();
        }

        // --- Layer Management (Unchanged logic) ---

        function createNewLayer(name = `Layer ${getActiveLayers().length + 1}`, setActive = true) {
            const layers = getActiveLayers();
            const newLayer = {
                name: name,
                data: createBlankGrid(iconWidth, iconHeight),
                visible: true,
            };
            layers.push(newLayer);
            if (setActive) {
                activeLayerIndex = layers.length - 1;
            }
            renderLayerList();
            updateUI();
        }

        function renderLayerList() {
            const layers = getActiveLayers();
            layerListDiv.innerHTML = '';
            
            if (layers.length === 0) {
                layerListDiv.innerHTML = '<p class="text-stone-500 text-sm p-2">No layers. Add a new layer.</p>';
                activeLayerNameSpan.textContent = 'None';
                return;
            }
            
            layers.slice().reverse().forEach((layer, originalIndex) => {
                const index = layers.length - 1 - originalIndex;
                
                const item = document.createElement('div');
                item.className = `item flex items-center justify-between p-2 cursor-pointer transition duration-100 ${index === activeLayerIndex ? 'active' : ''}`;

                item.innerHTML = `
                    <div class="flex items-center space-x-2 w-full text-stone-100">
                        <button class="toggle-visibility p-1 text-sm rounded-md hover:bg-stone-600" data-index="${index}" title="Toggle Visibility">
                            ${layer.visible ? 'üëÅÔ∏è' : 'üö´'}
                        </button>
                        <span class="layer-name flex-1 text-sm font-medium truncate" data-index="${index}">
                            ${layer.name} ${index === activeLayerIndex ? '<span class="text-accent">(Active)</span>' : ''}
                        </span>
                        <button class="edit-name p-1 text-sm rounded-md hover:bg-stone-600" data-index="${index}" title="Edit Name">
                            ‚úèÔ∏è
                        </button>
                    </div>
                    <button class="delete-layer ml-2 p-1 text-sm text-red-500 rounded-md hover:bg-red-900" data-index="${index}" title="Delete Layer" ${layers.length === 1 ? 'disabled' : ''}>
                        ${layers.length === 1 ? 'üîí' : '‚ùå'}
                    </button>
                `;

                item.addEventListener('click', () => setActiveLayer(index));
                item.querySelector('.toggle-visibility').addEventListener('click', (e) => {
                    e.stopPropagation();
                    layers[index].visible = !layers[index].visible;
                    renderLayerList();
                    updateUI();
                });
                item.querySelector('.delete-layer').addEventListener('click', (e) => {
                    e.stopPropagation();
                    if (layers.length > 1) {
                        layers.splice(index, 1);
                        if (activeLayerIndex >= index && activeLayerIndex > 0) {
                            activeLayerIndex--;
                        }
                        renderLayerList();
                        updateUI();
                    }
                });
                item.querySelector('.edit-name').addEventListener('click', (e) => {
                    e.stopPropagation();
                    const newName = prompt(`Enter new name for Layer ${index + 1}:`, layer.name);
                    if (newName && newName.trim() !== '') {
                        layers[index].name = newName.trim();
                        renderLayerList();
                    }
                });
                
                layerListDiv.appendChild(item);
            });
            
            if (layers.length > 0) {
                activeLayerNameSpan.textContent = layers[activeLayerIndex].name;
            }
        }
        
        function setActiveLayer(index) {
            activeLayerIndex = index;
            renderLayerList();
        }

        // --- Update UI & Export ---

        function updateExportBytes() {
            // Only update byte counts, do not display code by default
            const frameBytes = generateBitmapBytes(mergeVisibleLayers(getActiveLayers()));
            const singleSize = frameBytes.length;
            const animationSize = frames.reduce((sum, frame) => {
                const bytes = generateBitmapBytes(mergeVisibleLayers(frame.layers));
                return sum + bytes.length;
            }, 0);
            
            singleFrameByteCountSpan.textContent = singleSize;
            animationByteCountSpan.textContent = animationSize;
        }

        function updateUI() {
            if (frames.length === 0) return;

            drawScene(ctx, canvas, pixelSize, getActiveLayers());
            dimsText.textContent = `${iconWidth}x${iconHeight}`;

            renderFrameList();
            renderLayerList();
            updateExportBytes();

            if (isPlaying) stopAnimation();
        }

        // --- Drawing Handlers (Unchanged logic) ---
        
        function handleStart(e) {
            e.preventDefault();
            if (frames.length === 0 || document.getElementById('editor').classList.contains('hidden')) return;
            isDrawing = true;
            const { x, y } = getPixelCoords(e);
            startX = x; startY = y;
            drawingState = (currentTool === 'eraser' ? 0 : 1); 
            
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                setPixel(getActiveLayers()[activeLayerIndex].data, x, y, drawingState); 
            }

            updateUI();
        }

        function handleMove(e) {
            e.preventDefault();
            if (!isDrawing || frames.length === 0) return;
            const { x, y } = getPixelCoords(e);
            
            if (currentTool === 'pencil' || currentTool === 'eraser') {
                drawLine(getActiveLayers()[activeLayerIndex].data, startX, startY, x, y, drawingState);
                startX = x; startY = y;
                drawScene(ctx, canvas, pixelSize, getActiveLayers());
            }
        }

        function handleEnd(e) {
            if (!isDrawing || frames.length === 0) return;
            isDrawing = false;
            
            startX = -1; startY = -1;
            updateUI();
        }

        // --- Export & Import Logic (Modified to support download) ---

        function mergeVisibleLayers(layers) {
            const composite = createBlankGrid(iconWidth, iconHeight);
            for (let y = 0; y < iconHeight; y++) {
                for (let x = 0; x < iconWidth; x++) {
                    for (const layer of layers) {
                        if (layer.visible && layer.data[y][x] === 1) {
                            composite[y][x] = 1;
                            break; 
                        }
                    }
                }
            }
            return composite;
        }

        function generateBitmapBytes(compositeGrid) {
            const h_banks = Math.ceil(iconWidth / 8); 
            const byte_array = [];
            for (let y = 0; y < iconHeight; y++) { 
                for (let h_bank = 0; h_bank < h_banks; h_bank++) {
                    let current_byte = 0x00;
                    const start_x = h_bank * 8; 
                    for (let bit_col = 0; bit_col < 8; bit_col++) {
                        const x_bit = start_x + bit_col;
                        if (x_bit < iconWidth) {
                            let is_set = compositeGrid[y][x_bit]; 
                            if (is_set) { current_byte |= (1 << bit_col); }
                        }
                    }
                    byte_array.push(current_byte);
                }
            }
            return byte_array;
        }

        function formatBytes(byte_array, name) {
            let output = `// Frame: ${name} (${iconWidth}x${iconHeight}). Total Bytes: ${byte_array.length}\n`;
            output += `const uint8_t FRAME_BITMAP[${byte_array.length}] = {\n    `;
            for (let i = 0; i < byte_array.length; i++) {
                const hex = '0x' + byte_array[i].toString(16).toUpperCase().padStart(2, '0');
                output += hex;
                if (i < byte_array.length - 1) { output += ', '; }
                if ((i + 1) % 8 === 0 && i < byte_array.length - 1) { output += '\n    '; }
            }
            output += '\n};';
            return output;
        }

        function formatAnimationBytes(animationBytes) {
            const bytesPerFrame = animationBytes.length > 0 ? animationBytes[0].length : 0;
            let output = `// Animation Frames: ${frames.length} frames of ${iconWidth}x${iconHeight}.\n`;
            output += `// Total Data Size: ${frames.length * bytesPerFrame} bytes.\n`;
            output += `const uint8_t ANIMATION_BITMAPS[${frames.length}][${bytesPerFrame}] = {\n`;

            animationBytes.forEach((frameBytes, i) => {
                output += `    // Frame ${i}: ${frames[i].name}\n    { `;
                
                for (let j = 0; j < frameBytes.length; j++) {
                    const hex = '0x' + frameBytes[j].toString(16).toUpperCase().padStart(2, '0');
                    output += hex;
                    if (j < frameBytes.length - 1) { output += ', '; }
                    if ((j + 1) % 8 === 0 && j < frameBytes.length - 1) { output += '\n      '; }
                }
                
                output += ` }${i < animationBytes.length - 1 ? ',' : ''}\n`;
            });

            output += `};`;
            return output;
        }

        function downloadCFile(content, filename) {
            const blob = new Blob([content], { type: 'text/plain' });
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
        }
        
        // NEW: Function to handle code generation and display
        function generateAndDisplayCode(type) {
            if (frames.length === 0) return;
            
            let outputCode = '';
            let fileName = '';
            
            if (type === 'single') {
                const frameBytes = generateBitmapBytes(mergeVisibleLayers(getActiveLayers()));
                outputCode = formatBytes(frameBytes, getActiveFrame().name);
                fileName = `${getActiveFrame().name.toLowerCase().replace(/\s/g, '_')}_bitmap.c`;
                generateSingleFrameBtn.textContent = 'Generated!';
                setTimeout(() => generateSingleFrameBtn.textContent = `Generate Single Frame Array (${frameBytes.length} bytes)`, 2000);

            } else if (type === 'animation') {
                const allAnimationBytes = frames.map(frame => generateBitmapBytes(mergeVisibleLayers(frame.layers)));
                outputCode = formatAnimationBytes(allAnimationBytes);
                fileName = `animation_bitmaps.c`;
                const totalBytes = allAnimationBytes.length * (allAnimationBytes[0]?.length || 0);
                generateAnimationBtn.textContent = 'Generated!';
                setTimeout(() => generateAnimationBtn.textContent = `Generate Animation Array (${totalBytes} bytes)`, 2000);
            }

            byteOutputDiv.textContent = outputCode;
            outputContainer.classList.remove('hidden');
            
            // Store the generated code and file name for the export button
            exportCFileBtn.dataset.code = outputCode;
            exportCFileBtn.dataset.filename = fileName;
        }

        function parseBytes(arrayString) {
            const regex = /0x[0-9a-fA-F]{1,2}|\d+/g;
            const matches = arrayString.match(regex);
            if (!matches) return [];
            return matches.map(m => {
                return m.startsWith('0x') ? parseInt(m, 16) : parseInt(m, 10);
            }).filter(n => !isNaN(n) && n >= 0 && n <= 255);
        }

        function parseCArray(byte_array, width, height) {
            const grid = createBlankGrid(width, height);
            const h_banks = Math.ceil(width / 8);
            if (byte_array.length !== h_banks * height) { return null; }
            let byte_index = 0;
            for (let y = 0; y < height; y++) {
                for (let h_bank = 0; h_bank < h_banks; h_bank++) {
                    const bank_data = byte_array[byte_index++];
                    const start_x = h_bank * 8;
                    for (let bit_col = 0; bit_col < 8; bit_col++) {
                        const x = start_x + bit_col;
                        if (x < width) {
                            if (bank_data & (1 << bit_col)) { grid[y][x] = 1; }
                        }
                    }
                }
            }
            return grid;
        }

        function handlePreview() {
            const inputStr = arrayInput.value;
            const w = iconWidth;
            const h = iconHeight;
            const expectedBytes = Math.ceil(w / 8) * h;
            const bytes = parseBytes(inputStr);
            
            previewBytesSpan.textContent = `Bytes: ${bytes.length} (Expected: ${expectedBytes})`;

            if (bytes.length === 0) { 
                previewErrorP.textContent = 'No valid hex/decimal bytes found.';
                previewErrorP.classList.remove('hidden');
                commitImportBtn.disabled = true;
                commitImportBtn.classList.add('opacity-50', 'cursor-not-allowed');
                parsedGrid = null;
                return;
            }
            if (bytes.length !== expectedBytes) { 
                previewErrorP.textContent = `Byte count mismatch: Found ${bytes.length}, expected ${expectedBytes} for ${w}x${h}.`;
                previewErrorP.classList.remove('hidden');
                commitImportBtn.disabled = true;
                commitImportBtn.classList.add('opacity-50', 'cursor-not-allowed');
                parsedGrid = null;
                return;
            }
            
            parsedGrid = parseCArray(bytes, w, h);
            
            if (parsedGrid) {
                drawPreview(parsedGrid, w, h);
                previewErrorP.classList.add('hidden');
                commitImportBtn.disabled = false;
                commitImportBtn.classList.remove('opacity-50', 'cursor-not-allowed');
            } else { 
                previewErrorP.textContent = 'Failed to generate grid from array.';
                previewErrorP.classList.remove('hidden');
                commitImportBtn.disabled = true;
                commitImportBtn.classList.add('opacity-50', 'cursor-not-allowed');
            }
        }
        
        function drawPreview(grid, w, h) {
            const canvasW = previewCanvas.width;
            const canvasH = previewCanvas.height;
            const size = Math.min(canvasW / w, canvasH / h);
            previewCtx.clearRect(0, 0, canvasW, canvasH);
            previewCtx.fillStyle = '#000000'; // Black for import preview
            for (let y = 0; y < h; y++) {
                for (let x = 0; x < w; x++) {
                    if (grid[y][x] === 1) {
                        previewCtx.fillRect(x * size, y * size, size, size);
                    }
                }
            }
        }
        
        function handleImport() {
            if (parsedGrid && frames.length > 0) {
                getActiveLayers()[activeLayerIndex].data = parsedGrid;
                updateUI();
                hideImportModal();
            }
        }

        // --- Animation Player Logic (Unchanged logic) ---
        

        function animate(timestamp) {
            if (!isPlaying) return;

            if (!lastTimestamp) lastTimestamp = timestamp;
            const elapsed = timestamp - lastTimestamp;

            if (elapsed > animationSpeed) {
                animationFrame = (animationFrame + 1) % frames.length;
                lastTimestamp = timestamp;
                
                currentAnimationFrame = frames[animationFrame];
                playerCurrentFrameSpan.textContent = animationFrame + 1;
                
                drawScene(playerCtx, playerCanvas, pixelSize, currentAnimationFrame.layers);
            }

            animationFrameId = requestAnimationFrame(animate);
        }

        function playAnimation() {
            if (frames.length < 2) {
                // If only one frame, just draw it and don't play
                drawScene(playerCtx, playerCanvas, pixelSize, getActiveLayers());
                return; 
            }
            if (isPlaying) return;

            isPlaying = true;
            playStopBtn.innerHTML = '‚ùö‚ùö'; 
            playStopBtn.classList.replace('bg-red-600', 'bg-amber-600');
            lastTimestamp = 0;
            animationFrame = currentFrameIndex;
            animationSpeed = parseInt(speedInput.value, 10) || 250;
            currentAnimationFrame = frames[animationFrame];
            animationFrameId = requestAnimationFrame(animate);
        }

        function stopAnimation() {
            if (!isPlaying) return;

            isPlaying = false;
            playStopBtn.innerHTML = '‚ñ∂'; 
            playStopBtn.classList.replace('bg-amber-600', 'bg-red-600');
            cancelAnimationFrame(animationFrameId);
            
            drawScene(playerCtx, playerCanvas, pixelSize, getActiveLayers());
            playerCurrentFrameSpan.textContent = currentFrameIndex + 1;
        }

        function navigateFrame(direction) {
            stopAnimation(); 
            currentFrameIndex = (currentFrameIndex + direction + frames.length) % frames.length;
            selectFrame(currentFrameIndex);
        }

        // --- Initialization and Event Binding ---

        function switchTab(tabId) {
            document.querySelectorAll('.tab-page').forEach(page => page.classList.add('hidden'));
            document.getElementById(tabId).classList.remove('hidden');
            document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active-tab'));
            document.querySelector(`.tab-btn[data-tab="${tabId}"]`).classList.add('active-tab');

            if (tabId === 'editor') {
                updateUI();
            } else if (tabId === 'player') {
                stopAnimation();
                drawScene(playerCtx, playerCanvas, pixelSize, getActiveLayers());
                playerCurrentFrameSpan.textContent = currentFrameIndex + 1;
            }
        }

        function initTools() {
            toolPanelDiv.innerHTML = '';
            TOOLS.forEach(tool => {
                const btn = document.createElement('button');
                btn.id = `tool-${tool.id}`;
                btn.className = `tool-btn p-3 rounded-md transition duration-150 text-xl font-bold border border-stone-600 ${tool.id === currentTool ? 'active' : ''}`;
                btn.innerHTML = tool.icon;
                btn.title = tool.name;
                btn.addEventListener('click', () => {
                    currentTool = tool.id;
                    document.querySelectorAll('.tool-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    canvas.style.cursor = tool.cursor;
                });
                toolPanelDiv.appendChild(btn);
            });
            canvas.style.cursor = TOOLS.find(t => t.id === currentTool).cursor;
        }

        function initEditor(width, height) {
            iconWidth = width;
            iconHeight = height;

            pixelSize = MAX_CANVAS_WIDTH / iconWidth; 
            
            canvas.width = MAX_CANVAS_WIDTH;
            canvas.height = MAX_CANVAS_WIDTH * (iconHeight / iconWidth); 
            playerCanvas.width = MAX_CANVAS_WIDTH;
            playerCanvas.height = MAX_CANVAS_WIDTH * (iconHeight / iconWidth); 

            if (frames.length === 0) {
                addFrame(false); 
            } else {
                frames.forEach(frame => {
                    frame.layers.forEach(layer => {
                        const oldData = layer.data;
                        const newGrid = createBlankGrid(iconWidth, iconHeight);
                        for(let y = 0; y < Math.min(iconHeight, oldData.length); y++) {
                            for(let x = 0; x < Math.min(iconWidth, oldData[0].length); x++) {
                                newGrid[y][x] = oldData[y][x];
                            }
                        }
                        layer.data = newGrid;
                    });
                });
                selectFrame(currentFrameIndex); 
            }

            renderFrameList();
            renderLayerList();
            updateUI();
        }

        // Bind Drawing Events
        canvas.addEventListener('mousedown', handleStart);
        canvas.addEventListener('mousemove', handleMove);
        document.addEventListener('mouseup', handleEnd); 
        canvas.addEventListener('touchstart', handleStart);
        canvas.addEventListener('touchmove', handleMove);
        document.addEventListener('touchend', handleEnd);

        // Bind Controls
        document.getElementById('clearBtn').addEventListener('click', () => {
            if (frames.length > 0) {
                getActiveLayers()[activeLayerIndex].data = createBlankGrid(iconWidth, iconHeight);
                updateUI();
            }
        });
        
        document.getElementById('applyResBtn').addEventListener('click', () => {
            const w = parseInt(inputWidth.value, 10);
            const h = parseInt(inputHeight.value, 10);
            if (isNaN(w) || w < 1 || w > 84 || isNaN(h) || h < 1 || h > 48) { return; }
            initEditor(w, h); 
        });
        
        document.getElementById('newLayerBtn').addEventListener('click', () => {
            if (frames.length > 0) createNewLayer();
        });

        // Frame Reordering
        moveFrameUpBtn.addEventListener('click', () => moveFrame(-1));
        moveFrameDownBtn.addEventListener('click', () => moveFrame(1));

        // Frame Creation
        duplicateFrameBtn.addEventListener('click', () => {
            addFrame(true);
        });
        blankFrameBtn.addEventListener('click', () => {
            addFrame(false);
        });

        // NEW: Generation and Export Bindings
        generateSingleFrameBtn.addEventListener('click', () => generateAndDisplayCode('single'));
        generateAnimationBtn.addEventListener('click', () => generateAndDisplayCode('animation'));

        copyOutputBtn.addEventListener('click', () => {
            const code = byteOutputDiv.textContent;
            const tempTextArea = document.createElement('textarea');
            tempTextArea.value = code;
            document.body.appendChild(tempTextArea);
            tempTextArea.select();
            document.execCommand('copy');
            document.body.removeChild(tempTextArea);
            copyOutputBtn.textContent = 'Code Copied!';
            setTimeout(() => copyOutputBtn.textContent = 'Copy to Clipboard', 2000);
        });

        exportCFileBtn.addEventListener('click', (e) => {
            const code = e.target.dataset.code;
            const filename = e.target.dataset.filename || 'bitmap_export.c';
            if (code) {
                downloadCFile(code, filename);
                exportCFileBtn.textContent = 'Exported!';
                setTimeout(() => exportCFileBtn.textContent = 'Export (Download .c file)', 2000);
            }
        });
        
        // Modal Bindings
        mainImportBtn.addEventListener('click', showImportModal);
        cancelImportBtn.addEventListener('click', () => { hideImportModal(); updateUI(); }); 
        previewArrayBtn.addEventListener('click', handlePreview);
        commitImportBtn.addEventListener('click', handleImport);

        // Player Bindings
        playStopBtn.addEventListener('click', () => isPlaying ? stopAnimation() : playAnimation());
        nextFrameBtn.addEventListener('click', () => navigateFrame(1));
        prevFrameBtn.addEventListener('click', () => navigateFrame(-1));
        speedInput.addEventListener('input', (e) => {
            animationSpeed = parseInt(e.target.value, 10);
            if (isPlaying) {
                stopAnimation();
                playAnimation(); 
            }
        });

        // Tab Bindings
        document.querySelectorAll('.tab-btn').forEach(btn => {
            btn.addEventListener('click', () => switchTab(btn.dataset.tab));
        });

        function showImportModal() {
            if (frames.length === 0) { addFrame(false); }
            importModal.classList.remove('hidden');
            previewErrorP.classList.add('hidden');
            commitImportBtn.disabled = true;
            commitImportBtn.classList.add('opacity-50', 'cursor-not-allowed');
            previewDimsSpan.textContent = `W: ${iconWidth} H: ${iconHeight}`;
            previewBytesSpan.textContent = `Bytes: ${Math.ceil(iconWidth / 8) * iconHeight} (Expected)`;
            previewCtx.clearRect(0, 0, previewCanvas.width, previewCanvas.height);
            arrayInput.focus();
            arrayInput.select();
        }
        function hideImportModal() {
            importModal.classList.add('hidden');
            arrayInput.value = '';
            parsedGrid = null;
        }

        // --- Initial Load ---
        window.onload = function() {
            initTools();
            initEditor(parseInt(inputWidth.value, 10), parseInt(inputHeight.value, 10)); 
            switchTab('editor'); 
        };
    </script>
</body>
</html>

